---
title: "**JPEG Encoder**"
subtitle: "*A simplified OpenCL implementaion of the JPEG  encoding process*"
author:
  - name: Shoumik Dey (<>)
    affiliation: University of Stuttgart
    affiliation-url: https://www.uni-stuttgart.de/en/
  - name: Pritom Gogoi (3643765)
    affiliation: University of Stuttgart
    affiliation-url: https://www.uni-stuttgart.de/en/
  - name: Manpa Barman (3641301)
    affiliation: University of Stuttgart
    affiliation-url: https://www.uni-stuttgart.de/en/
date: today
abstract: |
  This project aims to implement a simplified version of the JPEG encoding process using OpenCL. As a part of the jpeg encoding process, the steps of color space conversion, downsampling, DCT, quantization, zigzag scanning, run length encoding and huffman encoding are implemented. Both the CPU and GPU implementations are compared and the performance is evaluated. 
---

[Download the pdf version.](report.pdf){target="_blank"}

# Introduction
JPEG stands for Joint Photographic Experts Group, which developed a standard for image compression. The actual file format for storing the compressed images are by using the JFIF ([ITU-T.871](https://www.w3.org/Graphics/JPEG/jfif3.pdf)) and EXIF standards.

JPEG uses an intelligent combination of lossy and lossless compression techniques, which consists of the following steps:
1. Color space conversion from RGB to YCbCr

2. Downsampling of the chroma channels

3. Block division and level shift

4. Discrete Cosine Transform (DCT)

5. Quantization

6. Zigzag scanning

7. Run length encoding

8. Huffman encoding





The following sections describes the theoratical background of each of the steps in brief. The implementation details are described in the [implementation](#implementation) section.  

## Color Space Conversion

Color Space Conversion is the process of converting the RGB color space to the YCbCr color space. The YCbCr
colour space has three components per pixel: 
 - The luminance, or the brightness of a pixel, Y
 - The amount of blue light in the pixel, Cb
 - The amount of red light in the pixel, Cr

Y is called  the luma component and the Cb and Cr are known as the chroma components. The RGB color space is a device dependent color space wheareas the YCbCr color space is a device independent color space, which makes it more suitable for image compression. The YCbCr color space is a linear combination of the RGB color space. The conversion from RGB to YCbCr is given by the following equations:

$$

\begin{align}

Y &= 0.299 \, R + 0.587 \, G + 0.114 \, B \\
Cb &= -0.1687 \, R - 0.3313 \, G + 0.5 \, B \\
Cr &= 0.5 \, R - 0.4187 \, G - 0.0813 \, B

\end{align}

$$

While the color space conversion itself is not lossy, it sets the stage for subsequent lossy operations that occur during image compression

## Downsampling or Chroma Subsampling

Our human eyes are more sensitive to the luminance component (Y) than the chroma components (Cr and Cb). Hence, downsampling the chroma components does not signigicantly impact the visual quality of the image. Thus the chroma components are subsampled by a factor of 2 in both the horizontal and vertical directions by taking the average of the four pixels. The luminance component is not subsampled.


Here we can use various subsampling ratios like 4:4:4, 4:2:2, 4:2:0, 4:1:1, 4:1:0. The first number (J) represents the horizontal sampling reference, which is usually four pixels. The second number is the number of chrominance samples (Cr, Cb) in the first row of J pixels. The third number is the change between the first and second row of chrominance pixels. This must either be zero or equal to the second number.


For example: The subsampling ratio of 4:2:0 means that the chroma components are subsampled by a factor of 2 both in the horizontal and vertical directions. 

This is an optiional step in the JPEG encoding process.

## Block Division and Level Shift

The image is divided into 8x8 blocks and each block is level shifted by subtracting 128 from each pixel. The range of each pixel value thus becomes [-128, 128]. Each 8x8 block is called Minimum Coded Unit (MCU).

This is done to make the DCT coefficients positive, for the next step.


## Discrete Cosine Transform (DCT)

DCT transforms the image from the spatial domain to the frequency domain. It is a linear transformation that allows us to express a sequence of discrete data elements in terms of sum of different frequencies into a sum of cosine functions oscillating at different frequencies. This step is done for each MCU. 

The DCT is defined as follows:

$$
    F(u,v) = \frac{1}{4} \, C(u) \, C(v) \, \sum_{x=0}^{7} \sum_{y=0}^{7} f(x,y) \, \cos \left[ \frac{(2x+1)u\pi}{16} \right] \, \cos \left[ \frac{(2y+1)v\pi}{16} \right]
  
where 
u is the horizontal spatial frequency
v is the vertical spatial frequency
f(x,y) is the pixel value at location (x,y)
C(u) = 1/sqrt(2) if u = 0, else C(u) = 1
C(v) = 1/sqrt(2) if v = 0, else C(v) = 1
F(u,v) is the DCT coefficient at location (u,v)

$$

After the DCT step, the top left corner contains larger magnitudes i.e. the low frequency componets that our eyes are good at observing and the bottom right corner contains smaller magnitudes or the higher frequency components.

The top left corner of the 8x8 block contains the DC coefficient and the rest of the coefficients are AC coefficients. The DC coefficient represents the average value of the 8x8 block and the AC coefficients represents  represent the variations or deviations from the average value across the block. The DC coefficient is usually much larger than the AC coefficients.

## Quantization

Quantization is the process of reducing the number of bits required to represent the DCT coefficients. This is done by dividing each DCT coefficient by a quantization factor and rounding off the result to the nearest integer. This step is also done for each MCU (8x8) and thus the quantization matrix used is also 8x8. The quantization factor is chosen such that the higher frequency components are quantized more than the lower frequency components i.e the higher frequency components of the matrix are made equal to zero. Each component of the quantization matrix determines how much each DCT coefficient is important. 

The chosen quantization matrices for each channel of the images determines the quality of the image. The high quality images have a low quantization matrix and the low quality images have a high quantization matrix. The quantization matrix is usually chosen empirically and it is provided in the JPEG standard for different quality levels.

Quantization is done using the formula below:
$$
 A^{\prime} = \sum_{i=0}^{7} \sum_{j=0}^{7} round(\frac{a_{i,j}}{Q_{i,j}})

$$


## Zigzag Scanning

After obtaining the quantized DCT coefficients, the next step is to convert each 8x8 MCU per channel into a 1x64 vector. This can be done by either horizonal/ vertical scanning of all the components of the MCU or by zigzag scanning. The later is used for JPEG encoding as it allows us to encode the image in such a way that the similar coefficients i.e. similar frequencies are grouped together.

## Run Length Encoding
As mentioned in the previous section the topmost left coefficient of the 8x8 block is the DC coefficient and the rest are the AC coefficients. When doing run length encoding, we do the AC and the DC parts differently. 

The DC part is encoded by taking the difference between the current DC coefficient and the previous DC coefficient i.e for each image, the first DC coefficient is encoded as it is and the rest of the DC coefficients are encoded as the difference between the current DC coefficient and the previous DC coefficient (adjacent MCU) of that image.

The AC part (the remaining 63 coefficients) for each MCU is encoded by using the run length encoding technique. The run length encoding technique is used to encode the number of zeros before the first non-zero AC coefficient and the number of zeros between two non-zero AC coefficients. The run length encoding is done by counting the number of zeros before the first non-zero AC coefficient which is called the run length. For example if the AC components are [12, 1, 0,0,0,2,3,0,3], then the run length encoding will be (current run length, current AC coefficient) = (0,12), (0,1), (3,2), (0,3), (1,3). The run length encoding is done for each MCU.

## Huffman Encoding
Huffman encoding is a lossless data compression technique. It is used to encode symbols into variable length code words according to their frequency of occurence. Similar to run length coding the Huffman encoding is done for the AC and the DC parts separately. The DC part is encoded by using the Huffman table provided in the JPEG standard which has the value category and the codeword for each symbol. The value category of the DC coefficient is determined by the difference between the current DC coefficient and the previous DC coefficient. The Huffman encoding is done for each MCU.

For the AC part, the Huffman code of any AC coefficient is given by the pair (RRRR,SSSS) where RRRR is the run length and SSSS is the value category of the AC coefficient. The final AC coefficient will finally look like 
(Huffman code for coefficient,bit representaion of value). The Huffman codes for the AC coefficients is also provided in the JPEG standard. This is done for each MCU.

For example: If the run length encoding is (0,âˆ’5) then RRRR=0 and SSSS=3 (value category of -5), which makes the Huffman code to be 100. The bit representation of -5 is 010, which makes the bit stream for this coefficient 100010. In the same way the bit stream for the rest of the coefficients are obtained.



References: [@Vitay2017]

See @fig-matrix and @sec-results.

![Afferent system to VTA. [@Vitay2017]](img/dopamine.jpg){#fig-matrix width=50%}

$$
    \tau \, \frac{dx_j(t)}{dt} + x_j(t)= \sum_i w^{in}_{ij} \, r^{in}_i(t) + g \, \sum_{i \neq j} w^{rec}_{ij} \, r_i(t)
$$

::: {.callout-note}
## Nota Bene

Important information.
:::

```python
for i in range(10):
    print(i)
```

## Second subsection

{{< video https://www.youtube.com/embed/tPgf_btTFlc >}}

# Material and methods

# Results {#sec-results}

# Discussion

# References {.unnumbered}


